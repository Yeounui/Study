def hammingDistance(strand1, strand2):
    strandlen = len(strand1)
    score = 0
    i = 0
    while (i < strandlen):
        if strand1[i] != strand2[i]:
            score += 1
        i += 1
    return score

#strand1 = 'TTGGCCCACTCTAACGCTGAGCCTGCGATGTAAGACATATCAAAATACATCCAGAGACCTCCCATGCCTGCTTTGCAGACAGCCCTCAGGGACGGAGCCTCAACCTCGACGACGAGGTGGCCTATGTAACCACAAAATTGCCAGAAGAAGCCTTGAGCCGGCGTTTTAGTGGGTCCGGTACGTATTCTCGTCTACTCACCGGGACTATATTCAGGTTTCTTTCTTCCTTGGACGGGGTCTATCGATGAGCTCTGGGCACAATGTGCTGACAAATTTCAAGGGGCAACTCGTATGCTTCCGTCAGCCGGGATCTAATATGTCACGTTTAACTCACCCCCGTATAACACATCAGGGCTCGCCTTCTTCCAATATCGCGGGCATATCCACTTCCCTATTCATTACTTTACAAAGCTTGTATAGTTAGAATAAGACTGCGAACGCCTCATAAAGTGGTATCTACATATTCTTCGTGTCCTCCAGGTCCGCAAAGCGATTTTACGCGTACAGCCACCTTTGGGTCGCTTGGGTTCGACTCCAGCCTCGTCGTTCTCGTGAATCACCGAAACAAACGTGCAGGAGGGTATATGCCTCCTCTCGAACTACGGCTCGGGAAAGTGATCCCTATTTTTTCAGAACCTCTTGGCCCACTGACTTACTCCCGCTTCCGTCCCCCCACCCGAGCTCAGCGTGTGTGGGGCCCATCGCAACCTAACACTAAGAGAGCTGAAACATTGTCGCATTTACCAAGGACGGAACATGGACAACGTTCGCTATGAGATGAACTACCAAATATGAAAGGTTCTTTTGGGCGCATCTCAATGGGGCTGGTCTGATCGGGTGGCCCTCGAGCTCAGATTCAGTCTGGTTCCACTAGGCCCGTAGCACCCCACTGCGGAAGGTATTAGGCCGCATCAATTTGTACCACTGGTGTAAATATACCCATGTCTACTCGCACTTCAATCGCGATTAGTCTGTCCGCCCACGACCCCAGAACTCCCGTCGCTATGTGGTCCCAAGACCGCCGCATAGCCTCTGTTCAAACTCGCTAATCGTTGGCATCGAAGCAAATATCGCCACGAGTCGTCGCATGACAAGATCAGTTGTGAGATGCTTTGGTGTCTATTGAGCTGCTGACATCATGTCGAGACAG'
#strand2 = 'ACATGTCGCAGTTGTATTAGAGCTCCGCTTTACACAACCTGTCCTATACTTTGTCTTAGCCGAAATCGATGTGTTGCGTCCGCGGTACAACTCTAGTAACGTGCTCTCACCGTCTATTAGTCACCTGTAGGGTTCTAAAAGCAACCCGTTACGAATACGCCGAGGGGACTCACAGACGTTACAATAATCGCCGTTTCCACAACAACTTCGCGGGGGCCCGTGCATAACTTATTCAAGTCGTACCTAAGGGAATACTGCGACAGAGTTGCACGACTTACTTCGATGCACTCGCCCACATCCATTATAGGTCTCGAGGAATTAAACGCAACATCCGTTCTGTACAGCAGACATTACGCCGCTTCCATGTGCTTGTACCGAGATTCCTGGTTTCACTCATGACGTTTGCCAGCTTGACGCTCTTCATCCCGAAGTGTGGCCGAAAAATTAGCCTGTCTATAGAAAATAGTCAGACGGGAGTGCAATACCACAACGCTGCTGTCTGTGCTCTTCTTTTCCAGCGTTTGACTCAATGGGCCGGTTGATTTGTACCTCCCGATCCTTGGGTGACCTTCAGTCTATCGCAGATTTCGTGACGTGGGCAAGGTATAACGAACAATTAAAAGAGTGGTGTACAGAAGCATACACTATCACGGCAATGTAGCGCCGGCTATCTTTGTCTGAATCGCCGGCACTAGGGCTTGACCTAGAGGGTGAGTAATCTCGTTACGGAGAAGAGCTAAGGACATCCCGTGCGTTCGATTCAATAAATATTGCGAGTGATCATTCCCGCTCACAAAAACTTGAACAGCTTCCACGCAGTGTCCTGGCTGAGTATACTACGAGGCGGCTTAGCGAGCTTCAGCGGCGTGAACGCCTGACTTAGTTAACCTATACATAACTGTTACTCCGAAATTAAGCTACGACCCCCCGGTATCTCGATCGAAAAAGCGGCGACACATAAGGACTCTGTTTGGAGGGGGTTTCGCCGGGTTATATAGCGGTGGATCGGGACGAGAGGTACAGCAGCTTATAAGGCTTCTAAACGCGTGCTTTCGACCTTGCCCTATAACCTTGCAATCGGCGCATAGGCGAGAATCCGTTTATCGGCCTCCGACGAACAGCCCTCCGTTATAGCAAAATAGCATCCACA'
#print(hammingDistance(strand1, strand2))

def matchApproxPattern(pattern, txt, mostMismatch):
    txtlen = len(txt)
    patternlen = len(pattern)
    posList = list()
    for i in range(txtlen-patternlen+1):
        if mostMismatch >= hammingDistance(pattern, txt[i:i+patternlen]):
            posList.append(str(i))
    return ' '.join(posList)

def countApproxPattern(txt, pattern, d):
    count = 0
    txtlen = len(txt)
    patternlen = len(pattern)
    for i in range(txtlen-patternlen+1):
        if d >= hammingDistance(pattern, txt[i:i+patternlen]):
            count += 1
    return count


if __name__ == "__main__":            
    pattern = "TGT"
    txt = "CGTGACAGTGTATGGGCATCTTT"
    mostMismatch = 1
    print(countApproxPattern(pattern, txt, mostMismatch))

    pattern1 = 'CTACAGCAATACGATCATATGCGGATCCGCAGTGGCCGGTAGACACACGT'
    pattern2 = 'CTACCCCGCTGCTCAATGACCGGGACTAAAGAGGCGAAGATTATGGTGTG'
    print(hammingDistance(pattern1,pattern2))
     

